[
  {
    "objectID": "modules/de-git-module.html#modulüberblick",
    "href": "modules/de-git-module.html#modulüberblick",
    "title": "Git, GitHub & Rstudio [DE]",
    "section": "Modulüberblick",
    "text": "Modulüberblick\nIn diesem Modul geht es um das Versionskontrollsystem git, den Cloud-Dienst GitHub und deren Verwendung in RStudio.\ngit ist ein Versionskontrollsystem, das die Erstellung von Snapshots von Dateien oder ganzen Verzeichnisbäumen ermöglicht. Auch das Kombinieren und Vergleichen solcher Snapshots ist komfortabel möglich.\nGitHub ist die bekannteste Cloud-basierte Arbeitsumgebung auf Basis von Git und bietet darüber hinaus eine Vielzahl webbasierter Werkzeuge und Dienste.\nRStudio ist als so genannte integrierte Entwicklungsumgebung (IDE) eine Desktop-Anwendung, die nicht nur für R/Python generische Programmieruntersützung bietet, sondern auch das wissenschaftliche Schreiben und Dokumentation, von Daten und Texten sehr gut unterstützt- Durch die vollständige Integration von Pandoc und Tex bietet es darüber hinaus eine weitgehende und sehr komfortable Unterstützung bei der Erstellung von Dokumenten in Form von Texten in allen denkbaren Formaten, interaktiven Dokumenten und Websites.\n\nLernziele\nAm Ende des Moduls werdet ihr in der Lage sein, git, GitHub und Rstudio effizient zu verwenden. Ein besonderer Schwerpunkt liegt dabei auf der praktischen Anwendung. Konkret beschäftigen wir uns mit:\n\nWas ist eine Versionskontrolle?\nWas unterscheidet git und GitHub?\nDie zentralen Vorgänge, Pull, Status, Add, Commit, Push\nVermeidung und Auflösung von Versionskonflikten\nNutzung mit RStudio"
  },
  {
    "objectID": "modules/de-git-module.html#git-und-github-leicht-gemacht",
    "href": "modules/de-git-module.html#git-und-github-leicht-gemacht",
    "title": "Git, GitHub & Rstudio [DE]",
    "section": "Git und GitHub leicht gemacht",
    "text": "Git und GitHub leicht gemacht\n\nLernziele\nIn dem Teilmodul Git und GitHub leicht gemacht lernst du:\n\ndas Konzept der Versionskontrolle\ndie Einsatzgebiete von GitHub und Git\n\n\n\nVoraussetzungen\n\nmit deinem Dateimanager navigieren und arbeiten\nein grundlegendes Verständnis von Datei- und Ordnerstrukturen\neinrichten eines GitHub-Accounts\ninstallierten von git\ninstalliertes R und RStudio\n\n\n\nÜberblick\nWas ist eine Versionskontrolle und wofür ist sie gut? Versionskontrollsysteme sind Softwaretools, die Personen bei der Verwaltung von Änderungen an Texten, Quellcode, wissenschaftlichen Analysen oder Dokumentationen unterstützen.\nIm Falle eines Fehlers können die Autor:innen die Änderungen einsehen und mit früheren (Teil-)Versionen vergleichen, um Korrekturen vorzunehmen und gleichzeitig die Unterbrechung ihrer eigenen Arbeit oder der Arbeit von Teammitgliedern zu minimieren.\nDu hast zum Beispiel einen Ordner, in dem du ein Projekt hast, das aus verschiedenen Dateien besteht (Text, Programmcode, Bilder, Sounddateien usw.), und du möchtest die Änderungen verfolgen, die du an diesen Dateien vorgenommen hast.\nDie Software git protokolliert alle Änderungen an diesen Dateien. Wie geht das?\n1. git mitteilen, dass eine Datei oder ein Verzeichnis aufgezeichnet werden soll.\n2. git mitteilen, dass der Zustand der Datei zu einem bestimmten Zeitpunkt aufgezeichnet werden soll.\nDieser Prozess ist also in zwei Schritte unterteilt, die kontrolliert und ausgelöst werden müssen. Um definierte Änderungen vornehmen zu können, muss festgelegt werden, was überwacht werden soll und es muss explizit bestätigt werden, dass ein definierter Zustand gespeichert wird. Im Prinzip muss also, wie bekannt, eine Momentaufnahme der Datei oder des Projektes bestätigt gespeichert werden.\nDer große Unterschied ist jedoch, dass nur die Änderungen dieses Sicherungsvorganges aufgezeichnet werden und später auch in diesen Teilschritten wiederhergestellt werden können.\n\n\nGit - Erste Schritte\nBei der Verwendung von Git muss zunächst ein Repository in einem Verzeichnis auf dem lokalen Rechner aktiviert werden. Dies geschieht mit dem Befehl git init. Nun weiß Git wo, aber nicht was es verfolgen soll.\n\n\n\n\ngraph LR\n    A(Erzeuge einen &lt;br&gt; neuen Ordner) -.-&gt; B[Lokaler Ordner &lt;br&gt; 'MeinOrdner']\n    B -- git init --&gt; C[Lokales Repository &lt;br&gt; 'Mein Ordner']\n    C -.- D(git überwacht &lt;br&gt; 'MeinOrdner' &lt;br&gt; 'kennt' aber keine Inhalte)\n  \n\n    classDef gr fill:#9f6,stroke:#333,stroke-width:2px\n    classDef bl fill:#6BC9F5,stroke:#333,stroke-width:2px,stroke-dasharray: 1\n    classDef or fill:orange,stroke:#333,stroke-width:1px,stroke-dasharray: 3\n    classDef or2 fill:orange,stroke:#333,stroke-width:3px,stroke-dasharray: 2\n    class A bl\n    class D gr\n    class C,B or\n\n%%{init: {'theme':'forest'}}%%\n\n\nInitialisierung eines Repositories\n\n\n\nDie Veränderungen an Dateien des Projekts werden jedoch nur dann übwerwacht wenn git ausdrücklich darüber “informiert” wird. Dies geschieht mit dem Befehl git add. Soll eine überwachte Datei gesichert werden erfolgt das mit dem Befehl git commit. Der Befehl, git push wird dann verwendet wenn die bestätigten Verzeichnis-Snapshot in ein entferntes Repository (z.B. Github, GitLab) übertragen werden sollen.\n\n\n\n\ngraph LR\n    AA[Projektordner &lt;br&gt; 'MeinOrdner'] --git init--&gt; \n    BB[Ordner ist als  &lt;br&gt; Repository vorbereitet] --git add DateiNeu--&gt;\n    CC(Die DateiNeu &lt;br&gt; wird 'überwacht') -.git commit.-&gt; \n    DD(Die Datei DateiNeu ist &lt;br&gt; in aktueller Version &lt;br&gt; lokal gespeichert) --git push--&gt; \n    EE(Die DateiNeu  ist &lt;br&gt; auf dem GitHub&lt;br&gt; Repo gespeichert)\n    \n    A[Projektordner &lt;br&gt; 'MeinOrdner'] -.-&gt; \n    B[Lokales Repository &lt;br&gt; 'MeinOrdner'] -- Erzeugen einer Datei --&gt;\n    C[Überwachte Datei &lt;br&gt; in 'MeinOrdner'] -.-&gt; \n    D[Dateiversion im &lt;br&gt; lokalen Repository ] -.-&gt; \n    E[Dateiversion im &lt;br&gt; entfernten Repository ]\n    \n\n    classDef green fill:#9f6,stroke:#333,stroke-width:2px\n    classDef blue fill:#6BC9F5,stroke:#333,stroke-width:2px,stroke-dasharray: 2\n    classDef orange fill:orange,stroke:#333,stroke-width:1px,stroke-dasharray: 3\n    class A blue\n    class B,C,D,D,E,F green\n    class DD,CC,AA,BB,EE orange\n\n\n\nAblauf init-add-commit-push\n\n\n\nMit dem Befehl ist git status erhälst du einen Überblick über den Status aller Dateien innerhalb eines initialisierten Repository Ordners. Du solltest in der Lage sein, die Ausgabe dieses Befehls zu interpretieren:\n\n\n\ngit status - konzeptionelle Inhalte\n\n\n\n\nGit/GitHub: pull, status, add, commit, push\nEs gibt zwei typische Szenarien für die Benutzung von Git und GitHub.\n\ndu hast das Projekt noch nicht gestartet und möchtest ein GitHub-Repository, das du als Vorlage auf deinen Rechner kopieren (klonen) und dann lokal mit Dateien und Verzeichnissen nach deinen Wünschen füllen kannst.\nDu hast das Projekt bereits lokal gestartet und möchtest es auf GitHub kopieren.\n\nBeide Szenarien werden von Jenny Bryan exzellent erläutert. Bitte lies diese Texte und folge den Anweisungen.\n\nSzenario 1: Happy Git With R: Kapitel 15 Neues Projekt GitHub\nSzenario 2: Happy Git With R: Kapitel 17 Bestehendes Projekt, GitHub\n\n\n\nTypische Probleme\n\nDu versuchst, git commit auszuführen, nachdem du Änderungen an einer Datei vorgenommen hast, aber du trackst diese Datei(en) nicht. Deshalb müssen Sie zuerst git add ausführen.\nDu versuchst git push auszuführen, um Deine Aktualisierungen in das entfernte Repository zu übertragen, aber dieses existiert nicht.\nDu versuchst git push auszuführen, um deine Aktualisierungen in das entfernte Repository zu übertragen, obwohl es bereits neue Aktualisierungen im entfernten Repository gibt (z.B. von einem anderen Teammitglied), die du noch nicht in das lokale Projekt übertragen hast. Die Fehlermeldung, die du bekommst, wird in etwa so aussehen:\n\n\nFehler: Deine lokalen Änderungen an den folgenden Dateien würden beim Zusammenführen überschrieben: … Bitte übertrage oder speichere deine Änderungen vor dem Zusammenführen.\n\nDu weist also dein lokales git an, deine eigenen Änderungen hinzuzufügen, ohne die Änderungen deines Teamkollegen zu berücksichtigen - ein klassischer Loyalitätskonflikt. Der beste Weg, dieses Problem zu vermeiden, ist immer einen git pull durchzuführen, bevor man mit dem lokalen Editieren beginnt.\n\n\nGut zu wissen\n\n\n\n\n\n\nWenn du mehr über Git erfahren möchtest, findest du hier weitere hilfreiche Ressourcen:\n\nPro Git: Kapitel Git Grundlagen\nHappy Git mit R\nPull tricky.\nGit Grundlagen\nGit und R\nRstudio - git - GitHub\n\n\n\n\n\n\nSelbst-Check"
  },
  {
    "objectID": "modules/de-git-module.html#fork-und-branches-auf-github",
    "href": "modules/de-git-module.html#fork-und-branches-auf-github",
    "title": "Git, GitHub & Rstudio [DE]",
    "section": "Fork und Branches auf GitHub",
    "text": "Fork und Branches auf GitHub\n\nLernziele\nIn dieser Lektion lernst du\n\nWas ein Fork/Branch eines GitHub-Repositorys ist.\nWie man einen Branch eines GitHub Repositories erstellt.\nWie Du ein GitHub Repository von einem Branch aus aktualisierst.\n\n\n\nVorausetzungen\n\nVertrautheit mit GitHub-Repositorys.\nGit muss auf deinem Computer installiert sein.\nEin GitHub Konto!\n\n\n\nWas ist ein Fork/Branch?\nWenn man in Gruppen an GitHub-Projekten arbeitet, wird es lästig, wenn eine Person den gesamten Code alleine in das Repository einpflegen muss. Hier kommen Forks und Branches ins Spiel. - Mit Branches kannst Du eine Kopie des aktuellen GitHub-Projekts nehmen und auf Deinem eigenen Computer Änderungen vornehmen. Sobald Du und Deine Gruppe Änderungen am Code vorgenommen habt, könnt Ihr die Änderungen wieder in Eure ursprüngliche Projektgruppe einfügen. - Branches können auch verwendet werden, wenn Du an einem Teil eines Projekts getrennt von den anderen Teilen arbeiten möchtest. - Forks sind sehr ähnlich, mit dem Unterschied, dass sie Kopien bzw Klone eines kompletten Projekts an einem anderen Ort sind.\n\nWie erstelle ich einen Branch?\nUm einen Branch von einem GitHub Repository zu erstellen, gehe zu dem Hauptrepository, an dem du arbeiten möchtest und klicke auf das Dropdown-Menü, das “main” heißen sollte. Es sollte wie das folgende Bild aussehen.\n\n\n\nBranch Menu in GitHub\n\n\nSobald man auf dieses Menü klickt, erscheint auf GitHub ein Textfeld mit der Aufschrift “Find or create a branch…”, man gibt einen neuen Namen für den Zweig ein, z.B. ‘newbranch1’. Da dieser Zweig noch nicht existiert, fragt dich GitHub, ob du einen Zweig mit dem Namen “newbranch1” erstellen möchtest. Klicke auf “Create branch: newbranch1” und der neue Zweig wird für Dich erstellt, wie in der folgenden Abbildung zu sehen ist.\n\n\n\nErzeugung eines neuen Branches\n\n\n\n\nWie stellt man einen Pull Request?\nEine Pull-Anfrage ermöglicht es dem Eigentümer des GitHub-Projekts, Deine Änderungen zu überprüfen, um sicherzustellen, dass sie in das aktuelle Repository passen und keine Konflikte in Deinem Repository verursachen.\nUm eine Pull-Anfrage von Deinem Zweig aus zu stellen, musst Du zuerst eine Änderung an Deinem Zweig-Repository vornehmen. Sobald Du eine Änderung an Deinem Zweig vorgenommen hast, erscheint ein gelber Balken auf Deinem Bildschirm, der Dich fragt, ob Du eine Pull-Anfrage stellen möchtest. Wie Du auf dem Bild unten sehen kannst, gibt es einen grünen Button, und sobald Du darauf klickst, kannst Du eine Pull-Anfrage erstellen.\n\n\n\nInitialisierung eines Pull Requests\n\n\nSobald Du auf den Button klickst, informiert Dich GitHub, ob es Probleme beim Zusammenführen des Zweigs mit dem Hauptprojekt gibt. Wenn es keine Probleme gibt, setzt GitHub ein Häkchen und zeigt “Able to merge” an. Du kannst dann einen Titel und einen Kommentar zu Deiner Pull-Anfrage hinzufügen, um den Besitzer des Repositorys darüber zu informieren, was Du getan hast. Sobald Du einen Kommentar und einen Titel eingegeben hast, kannst Du auf “Create a pull request” klicken. Wenn Du dies getan hast, wird eine Benachrichtigung an den Besitzer des Repositorys gesendet, dass Deine Änderungen zur Überprüfung bereit sind.\nNachdem Du Deine Anfrage abgeschickt hast, kann der Besitzer des GitHub-Projekts auf die Seite des Projekts gehen und auf den Reiter “Pull Requests” klicken. Auf dieser Seite wird eine Liste von Pull Requests angezeigt, aus der der Eigentümer Deine Anfrage auswählen kann. Sobald der Besitzer auf der Pull Request Seite angekommen ist, sieht er eine Schaltfläche mit der Aufschrift “Merge pull request” (ähnlich der Abbildung unten).\n\n\n\nBearbeitung eines Pull Requests\n\n\nSobald der Eigentümer auf die grüne Schaltfläche klickt, wird er erneut gefragt, ob er die Änderung vornehmen möchte. Wenn er erneut auf den Button klickt, wird die Änderung mit dem Hauptzweig zusammengeführt und er sieht etwas wie das folgende Bild…\n\n\n\nMergen eines verifizierten Pull Request\n\n\n\n\n\nEin Repository in einem Branch (oder Fork) aktualisieren\nWenn jemand in deiner Gruppe eine Änderung am Master Repo vornimmt, gibt es eine Möglichkeit, deinen Zweig zu aktualisieren, damit du die Änderungen sehen kannst. Wenn eine Änderung vorgenommen wurde, wird auf der Webseite des verzweigten Repos angezeigt, dass Dein Repo “1 Commit behind the Master” ist. Das bedeutet, dass es 1 Änderung zwischen Deinem Fork und dem Main Repository gibt.\nWenn Du Deinen Fork aktualisieren möchtest, klicke auf die Schaltfläche “Änderungen”. Du wirst dann auf eine Seite geleitet, die sagt “main is up to date with all commits from branch. Versuchen Sie die Basis zu ändern”. Klicke auf “Change base”. Dann wird angezeigt, ob der Zweig zusammengeführt werden kann. Wenn ja, klicke auf “Create pull request” (Titel und Kommentar für deine Anfrage) und erstelle eine Pull-Anfrage.\nNun klicke auf Merge pull request, dann auf Confirm merge und dein Zweig wird aktualisiert!\n\n\nGut zu wissen\n\n\n\n\n\n\n\nLerne wie man Branches mit dem Terminal erstellt: Arbeiten mit Branches\nLerne die Verwendung von Pull Requests und Issues: Issues und Pull Requests\nLerne, wie man ein GitHub-Repository forkt: Forken eines Repositories\n\n\n\n\n\n\nSelbst-Check"
  },
  {
    "objectID": "modules/de-git-module.html#umgang-mit-konflikten",
    "href": "modules/de-git-module.html#umgang-mit-konflikten",
    "title": "Git, GitHub & Rstudio [DE]",
    "section": "Umgang mit Konflikten",
    "text": "Umgang mit Konflikten\n\nLernziele\nIn dieser Lektion lernst du\n\nWie man mit Konflikten umgeht, die bei der Arbeit mit GitHub auftreten.\nWie man mit Merge-Konflikten in GitHub umgeht.\n\n\n\nVorausetzungen\n\nVertrautheit mit GitHub.\nGit installiert haben.\nEin GitHub Konto haben.\n\n\n\nVersionskonflikt - was ist das?\nVersionskonflikte entstehen normalerweise, wenn verschiedene Versionen derselben Datei gleichzeitig in das Hauptrepository gepusht werden und die Priorisierung der Dateien nicht klar ist, also:\n\nwenn man sein persönliches GitHub-Repository aktualisiert (kein Pull vor Push).\nwenn mehrere Personen gleichzeitig an derselben Datei arbeiten\n\n\n\nPush & Pull Konflikte\nEin typisches Szenario ist, dass Du etwas online auf GitHub bearbeitest und diese Änderung nicht gleichzeitig oder später in Rstudio synchronisierst. Der Konflikt könnte z.B. sein, dass Du einen Tippfehler in der README korrigierst und vergisst, die aktuelle Version im Rstudio-Projekt zu aktualisieren.\nEin komplizierterer Fall ist, wenn eine Änderung im Master-Repository gemacht wurde und jemand anderes in seinem Branch-/Fork-Repository ebenfalls eine Änderung an der gleichen Datei bzw. dem gleichen Inhalt gemacht hat. Wenn eine Pull-Anfrage gestellt wird, wird GitHub den Unterschied bemerken. Auch hier kann es sich um etwas so Einfaches handeln, wie zwei Personen, die die README auf unterschiedliche Weise aktualisieren, was GitHub dazu veranlasst, ein Problem zu melden.\nIn diesem Fall muss manuell entschieden werden, welche Variante Vorrang hat.\nWenn Du eine Änderung an Deinem GitHub-Repository vornimmst und es gibt einen Konflikt, zeigt Dir R an, dass Deine Version dem Haupt-Repository voraus ist, wenn Du Deine Änderung überträgst. Wenn Du dies siehst, bedeutet es, dass es einen Unterschied zwischen den Dateien gibt. Wenn Du versuchst zu pullen und es gibt ein Problem, wird GitHub Dir etwas sagen wie\n\nUpdates wurden abgelehnt, weil das entfernte Repository Arbeit enthält, die Du lokal nicht hast. Dies wird normalerweise durch ein anderes Repository verursacht, das auf die gleiche Referenz pusht.\n\nWenn diese Meldung erscheint, empfiehlt GitHub, dass Du einen Pull von Deinem Master-Repository durchführst, um den Fehler zu finden. Häufig erhältst Du die Fehlermeldung\n\nCONFLICT (content): Konflikt beim Zusammenführen in [Datei]. Automatisches Zusammenführen fehlgeschlagen; Konflikte lösen und dann das Ergebnis übertragen.\n\nDie Datei mit dem Problem wird dann in Ihrem RStudio geöffnet und zeigt den gefundenen Fehler an. Es wird angezeigt, welche Änderungen vorgenommen wurden und welche Unterschiede zum Hauptzweig bestehen (die Änderungen werden unter &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD angezeigt, der Inhalt des Hauptzweigs wird darunter angezeigt). Du musst den Fehler zwischen den beiden Versionen beheben, indem Du entweder das beibehältst, was GitHub bereits hat, oder indem Du Deine Änderung so anpasst, dass sie dem entspricht, was Du machen wolltest. Wenn Du mit Deiner Änderung zufrieden bist, rufe das Terminal auf (es befindet sich in R, einem Tab über der Konsole). Im Terminal gibst Du git add [Dateiname] ein, drückst die Eingabetaste und gehst zurück zum Git-Tab oben rechts im RStudio-Fenster. Wähle die Datei aus, in der der Fehler aufgetreten ist und überschreibe sie, um den Fehler zu beheben.\n\n\nMerge Konflikte\nWenn mehrere Personen am selben GitHub-Repository arbeiten oder Du nur einen Zweig verwendest, besteht die Möglichkeit, dass ein Merge-Konflikt auftritt. Zusammenführungskonflikte treten auf, wenn Änderungen am Haupt-Repository und an einem Zweig vorgenommen werden, die nicht übereinstimmen. Sobald eine Pull-Anfrage gestellt wird, muss der Eigentümer des Projektarchivs die Änderungen manuell überprüfen, sie können dann nicht automatisch zusammengeführt werden.\nFolglich teilt GitHub Dir mit, dass es die Versionen nicht automatisch zusammenführen kann, aber es wird Dir trotzdem erlauben, die Pull-Anfrage zu stellen. Wenn Du Dich entscheidest, die Pull-Anfrage zu senden, wird der Repo-Besitzer nicht in der Lage sein, auf den grünen Merge Button zu klicken, sondern er wird eine Meldung sehen, die besagt:\n\nDieser Zweig hat Konflikte, die gelöst werden müssen.\n\nRechts neben dieser Meldung befindet sich die Schaltfläche Konflikte auflösen.\nWenn du auf die Schaltfläche Konflikte auflösen klickst, wirst du zu einer Seite weitergeleitet, die ähnlich aussieht wie bei Push- oder Pull-Fehlernt. Du siehst die vorgeschlagenen Änderungen aus dem Zweig und Haupt-Repository. An dieser Stelle können dann Änderungen durchgeführt werden und zuletzt mit Als gelöst markieren und anschließend Merge bestätigen erfolgreich für einen Merge bereitgestellt werden. Zuletzt muss der Eigentümer auf Merge Pull Request und dann auf Commit Merge klicken, um die Änderung im Haupt-Repository zu vorzunehmen.\n\n\nGut zu wissen\n\n\n\n\n\n\n\nImmer pull vor push, sonst hat GitHub zwei verschiedene Änderungen gespeichert und weiß nicht, welche zu verwenden ist.\nWeitere Informationen über den Umgang mit Konflikten in GitHub findest Du in den GitHub Docs.\n\n\n\n\n\n\nSelbst-Check"
  },
  {
    "objectID": "modules/de-git-module.html#rstudio---all-inclusive",
    "href": "modules/de-git-module.html#rstudio---all-inclusive",
    "title": "Git, GitHub & Rstudio [DE]",
    "section": "RStudio - All Inclusive",
    "text": "RStudio - All Inclusive\n\nLernziele\n\nEinsatz von GitHub direkt aus RStudio\n\n\n\nVorausetzungen\n\nÜbung im Umgang mit GitHub und git\n\n\n\nExistierendes GitHub Repo in R einbinden\nBevor du mit einem GitHub-Repository in RStudio arbeitest, stelle sicher, dass du ein GitHub-Repository hast, mit dem du arbeiten kannst.\nNachdem du das Repository erstellt hast, kannst du auf die grüne Schaltfläche klicken, um einen Link zu erhalten, mit dem du das Repository klonen kannst. Um es in R zu öffnen, öffne R und klicke auf den Würfel mit dem Pluszeichen, um ein neues Projekt zu erstellen, klicke auf Versionskontrolle und dann auf Git. Nun fügt man die zuvor kopierte URL ein und erstellt das Projekt. Jetzt hast du ein Projekt in R, das mit GitHub verbunden ist. Nun kannst du neue Dateien erstellen und sie auf GitHub hochladen, damit andere sie sehen können.\n\n\nErklärung der Schaltflächen/Befehle\nOben rechts (je nach Konfiguration von RStudio) befinden sich die Reiter Environment, History... Wähle die Registerkarte Git, um die Git-Befehle zu sehen. In diesem Bereich kannst Du entscheiden, welche Dateien hochgeladen/gelöscht, welche Änderungen übernommen, welche Dateien aus dem Haupt-Repository gezogen, welche Dateien in das Haupt-Repository geschoben werden sollen. Die vorgenommenen Änderungen werden hier überprüft und es können Branches erstellt oder geändert wrden. Sehen wir uns nun an, was die einzelnen Befehle/Schaltflächen bewirken.\n\nDiff Wenn du auf Diff klickst, öffnet sich ein neues Fenster in R. In diesem Fenster werden alle Dateien angezeigt, die sich geändert haben (im Vergleich zum Haupt-Repository) und auch die Änderungen, die du vorgenommen hast. Du kannst dieses Fenster auch verwenden, um die Änderungen zu übertragen und aus dem Haupt-Repository herauszuziehen.\nCommit Die Verwendung von Commit im kleineren Fenster ist ähnlich wie im Diff-Fenster, Du musst nur die Dateien auswählen, die Du ins Repository übertragen möchtest und dann die Änderungen committen.\nPull Pull ist ziemlich selbsterklärend, es zieht Dateien aus dem GitHub Repository. Es ist wichtig, Dateien vor dem Pushen zu ziehen, um mögliche Konflikte mit überlappenden Dateien zu vermeiden.\nPush Push schiebt die Dateien in das GitHub Repository. Diese Funktion wird verwendet, wenn Du die Änderungen an Deinen Dateien abgeschlossen hast und bereit bist, sie hochzuladen, damit andere die neuen Dateien ansehen können. Die Reihenfolge beim Hochladen dieser Dateien wäre: Änderungen übertragen, aus dem Repository ziehen und dann in das Repository pushen.\nHistory Das nächste Symbol ist eine kleine Uhr, die die Historie Deiner Arbeit darstellt. Sie zeigt die bisherigen Übertragungen und was bei jeder Übertragung geändert wurde.\nRevert, Ignore und Shell Diese Befehle findest Du in einem Dropdown-Menü, nachdem Du auf das Zahnrad neben der Uhr geklickt hast. Mit Revert kannst Du alle Änderungen rückgängig machen, mit Ignore kannst Du einen Gitignore einrichten (nützlich, um Dateien zu blockieren, die Du nicht hochladen willst) und mit Shell kannst Du Dein Terminal öffnen und dort Git-Befehle ausführen.\nBranches Das nächste Symbol steht für Zweige. Wenn Du auf dieses Symbol klickst, wirst Du gefragt, ob Du einen neuen Zweig erstellen möchtest. Wie Du im Modul Zweige des Toolkits gelernt hast, sind Zweige nützlich, um Änderungen zu testen, ohne dass sie sich auf den Hauptzweig auswirken, falls ein Fehler auftritt. Du kannst das Dropdown-Menü rechts neben dem Zweigsymbol verwenden, um zwischen den Zweigen zu wechseln.\nTerminal (optional) Du kannst diese GitHub-Befehle mit den RStudio-Befehlen ausführen, aber du kannst auch das Terminal in R verwenden, um das gleiche zu tun. Alle GitHub-Befehle sind in der Form “git _____” und Du kannst sie finden, indem Du “git” in Dein Terminal eingibst. Dies macht dasselbe wie das R-Panel, aber wenn Du mit dem Schreiben von Git-Befehlen in einem Terminal vertrauter bist, funktioniert es vielleicht besser für Dich.\n\n\nEin R-Projekt in ein GitHub-Repositorium verwandeln\nManchmal arbeitet man an einem Projekt in R und hat vergessen, ein GitHub-Repository dafür zu erstellen. In diesem Fall kann Ihnen das Paket usethis helfen, ein Repo aus RStudio heraus zu erstellen. Mit der Funktion usethis::use_git kann das aktuelle Projekt in ein GitHub Repo umgewandelt werden, so dass die Dateien hochgeladen werden können. - Wenn Du diese Funktion zum ersten Mal ausführst, wirst Du wahrscheinlich einen Fehler erhalten, da Du dafür ein Token von GitHub benötigst. Nach dem Aufruf von usethis::browse_github_token öffnet sich ein neues Fenster, in dem man aufgefordert wird, sich in seinen GitHub-Account einzuloggen. Nach dem Einloggen können Berechtigungen mit dem Token gesetzt und kopiert werden. Sobald du den Token kopiert hast, rufe usethis::edit_r_environment() auf und speichere deinen Token als “GITHUB_PAT=token”.\nSobald dein Token gesetzt und dein R zurückgesetzt ist, kannst du use_git benutzen und es wird Dich fragen, ob es okay ist, deine Dateien zu GitHub zu committen. Wenn du diese Frage bejahst, wirst du aufgefordert, dein RStudio-Fenster neu zu starten, um das Git-Fenster zu öffnen und deine Dateien hochzuladen. Nach dem Neustart von RStudio die geänderten Dateien (falls vorhanden) mit dem Diff-Button hochladen. Benutze nun usethis::use_github, um deine Dateien in ein GitHub-Repository zu senden. - use_github wird Dich fragen, ob Du einen ssh Schlüssel hast, was Du wahrscheinlich nicht hast, also wähle https. Dann wird man gefragt, ob Titel und Beschreibung akzeptabel sind. Wenn ja, kannst Du mit Ja antworten und die Datei auf GitHub hochladen!\n\n\n\nGut zu wissen\n\n\n\n\n\n\nWeitere Informationen zur Verwendung von GitHub in RStudio findest Du unter folgendem Link:\n\nDer Blog-Eintrag GitHub & Rstudio zeigt, wie man Git in RStudio benutzt und geht dabei besonders auf die Terminal-Befehle ein.\n\n\n\n\n\n\n\n\nSelbst-Check"
  },
  {
    "objectID": "modules/de-git-module.html#danksagung",
    "href": "modules/de-git-module.html#danksagung",
    "title": "Git, GitHub & Rstudio [DE]",
    "section": "Danksagung",
    "text": "Danksagung\nDas Tutorial basiert auf dem DoSStoolkit. insbesondere unter Nutzung des Moduls Git outta here von Mariam Walaa & Matthew Wankiewicz. Die Übersetzungen und Veränderungen sowie eininge der Graiken sind vom Autor dieser Seite.\nDas Originalmodul kann mit dem folgenden R-Befehl aufgerufen werden.\n\nlearnr::run_tutorial(\"git_outta_here\", package = \"DoSStoolkit\")"
  },
  {
    "objectID": "modules/en-git-module.html#module-overview",
    "href": "modules/en-git-module.html#module-overview",
    "title": "Git, GitHub & Rstudio [EN]",
    "section": "Module overview",
    "text": "Module overview\nThis module is about the version control system git, the cloud service GitHub and their use in RStudio.\ngit is a version control system that allows the creation of snapshots of files or entire directory trees. Combining and comparing such snapshots is also convenient.\nGitHub is the best-known cloud-based working environment based on Git and also offers a variety of web-based tools and services.\nRStudio’ as a so-called integrated development environment (IDE) is a desktop application that not only offers generic programming support for R/Python, but also supports scientific writing and documentation, data and texts very well. Through the complete integration of ‘Pandoc’ and ‘Tex’, it also offers extensive and very convenient support for the creation of documents in the form of texts in all conceivable formats, interactive documents and websites.\n\nLearning objectives\nAt the end of the module you will be able to use git, GitHub and Rstudio efficiently. Special emphasis will be placed on practical application. Specifically, we will deal with:\n\nWhat is version control?\nWhat is the difference between git and GitHub?\nThe central operations, Pull, Status, Add, Commit, Push.\nAvoiding and resolving version conflicts\nUse with RStudio"
  },
  {
    "objectID": "modules/en-git-module.html#git-and-github-made-easy",
    "href": "modules/en-git-module.html#git-and-github-made-easy",
    "title": "Git, GitHub & Rstudio [EN]",
    "section": "Git and GitHub made easy",
    "text": "Git and GitHub made easy\n\nLearning objectives\nIn the sub-module Git and GitHub made easy you will learn:\n\nthe concept of version control\nthe areas of application of GitHub and Git\n\n\n\nPrerequisites\n\nnavigate and work with your file manager\na basic understanding of file and folder structures\nset up a GitHub account\ninstalled git\ninstalled [R] and [RStudio\n\n\n\nOverview\nWhat is version control and what is it good for? Version control systems are software tools that help people manage changes to text, source code, scientific analysis or documentation.\nIn the event of an error, authors can view the changes and compare them with previous (partial) versions to make corrections while minimising disruption to their own work or the work of team members.\nFor example, you have a folder in which you have a project that consists of various files (text, programme code, images, sound files, etc.), and you want to keep track of the changes you have made to these files.\nThe software git logs all changes to these files. How does it do this?\n1. Tell git that you want to log a file or directory.\n2. Tell git that you want to log the state of the file at a certain time.\nSo this process is divided into two steps that need to be controlled and triggered. In order to be able to make defined changes, it must be specified what is to be monitored and it must be explicitly confirmed that a defined state is to be saved. In principle, therefore, a snapshot of the file or project must be saved in a confirmed manner, as is known.\nThe big difference, however, is that only the changes of this saving process are recorded and can later be restored in these partial steps.\n\nGit - First Steps\nWhen using Git, the first step is to activate a repository in a directory on the local computer. This is done with the command git init. Now Git knows where to track, but not what to track.\n\n\n\n\ngraph LR\n\n    A[Create a &lt;br&gt; new folder] \n    B[Local folder &lt;br&gt; MyFolder] -- git init --&gt; C[Local repository &lt;br&gt; MyFolder]\n    C -.- D(git monitors 'MyFolder'  but knows *no* contents)  \n\n    classDef gr fill:#9f6,stroke:#333,stroke-width:2px\n    classDef bl fill:#6BC9F5,stroke:#333,stroke-width:4px\n    classDef or fill:orange,stroke:#333,stroke-width:1px,stroke-dasharray: 3\n    classDef or2 fill:orange,stroke:#333,stroke-width:3px,stroke-dasharray: 1\n    class A or2\n    class B,C gr\n    class D or\n\n%%{init: {'theme':'forest'}}%%\n\n\n\ninitialisation of a repository\n\n\n\nHowever, the changes to files in the project will only be applied if git is explicitly “informed” of what is to be done with these files. This is done with the two commands git add and git commit. The command, git push is used when the committed directory snapshot is to be committed to a remote repository (e.g. Github, GitLab).\n\n\n\n\ngraph LR\n    Z(Create a &lt;br&gt; new file)\n    \n    A[Local directory ] -- git add 'filename' --&gt; B[File in &lt;br&gt;staging area]\n    B -- git commit --&gt; C[file version in &lt;br&gt;local repository ]\n    C -- git push --&gt; D[file version in &lt;br&gt; remote repository ]\n    \n    AA[Empty folder] -.-&gt; BB(git monitors the file)\n    BB -.-&gt; CC(git backs up local &lt;br&gt; current state of file)\n    CC -.-&gt; DD(git saves remotely &lt;br&gt; current state of the file)\n    \n\n    classDef green fill:#9f6,stroke:#333,stroke-width:2px\n    classDef blue fill:#6BC9F5,stroke:#333,stroke-width:4px\n    classDef orange fill:orange,stroke:#333,stroke-width:1px,stroke-dasharray: 3\n    class A blue\n    class B,C,D green\n    class Z,DD,CC,AA,BB orange\n\n\n\nprocess stage commit push a file\n\n\n\nWith the command git status you get an overview of the status of all files within an initialised repository folder. You should be able to interpret the output of this command:\n\n\n\ngit status - conceptual content\n\n\n\n\n\nGood to know\n\nIf you want to learn more about Git, you can find more helpful resources here:\n\nPro Git: Chapter Git Basics\nHappy Git with R"
  },
  {
    "objectID": "modules/en-git-module.html#gitgithub-pull-status-add-commit-push",
    "href": "modules/en-git-module.html#gitgithub-pull-status-add-commit-push",
    "title": "Git, GitHub & Rstudio [EN]",
    "section": "Git/GitHub: pull, status, add, commit, push",
    "text": "Git/GitHub: pull, status, add, commit, push\n\nLearning objectives\nBased on the information from the previous chapter, in this lesson you will learn how to\n\ncreate a local repository in a folder\nmake changes to a remote repository\nmanage a local repository\n\n\n\nPractical use of git and GitHub\nThere are two typical scenarios for using git and GitHub.\n\nyou haven’t started the project yet and want a GitHub repository that you can copy (clone) to your computer as a template and then fill locally with files and directories as you wish.\nyou have already started the project locally and want to copy it to GitHub.\n\nBoth scenarios are excellently explained by Jenny Bryan. Please read them and follow the instructions.\n\nScenario 1: Happy Git With R: Chapter 15 New Project GitHub\nScenario 2: Happy Git With R: Chapter 17 Existing Project, GitHub\n\n\n\nTypical problems\n\nYou try to run git commit after making changes to a file, but you don’t track that file(s). Therefore, you need to run git add first.\nYou are trying to run git push to push your updates to the remote repository, but it does not exist.\nYou are trying to run git push to commit your updates to the remote repository, even though there are already new updates in the remote repository (e.g. from another team member) that you have not yet committed to the local project. The error message you get will look something like this:\n\n\nError: Your local changes to the following files would be overwritten during the merge: … Please commit or save your changes before merging.\n\nSo you’re telling your local git to add your own changes without taking your teammate’s changes into account - a classic loyalty conflict. The best way to avoid this problem is to always do a git pull before you start editing locally.\n\n\nGood to know\n\nFor a better understanding read the following texts:\n\npull tricky.\nGit basics\nGit and R\nRstudio - git - GitHub\n\n\n\n\nSelf-Check"
  },
  {
    "objectID": "modules/en-git-module.html#fork-and-branches-on-github",
    "href": "modules/en-git-module.html#fork-and-branches-on-github",
    "title": "Git, GitHub & Rstudio [EN]",
    "section": "Fork and Branches on GitHub",
    "text": "Fork and Branches on GitHub\n\nLearning objectives\nIn this lesson you will learn\n\nWhat a fork/branch of a GitHub repository is.\nHow to create a branch of a GitHub repository.\nHow to update a GitHub repository from a branch.\n\n\n\nPrerequisites\n\nFamiliarity with GitHub repositories.\nGit must be installed on your computer.\nA GitHub account!\n\n\n\nWhat is a fork/branch?\nWhen working in groups on GitHub projects, it gets annoying when one person has to commit all the code to the repository alone. This is where forks and branches come in. - With branches, you can take a copy of the current GitHub project and make changes on your own computer. Once you and your group have made changes to the code, you can paste the changes back into your original project group. - Branches can also be used if you want to work on one part of a project separately from the other parts. - Forks are very similar, except that they are copies or clones of a complete project in a different location.\n\nHow do I create a branch?\nTo create a branch from a GitHub repository, go to the main repository you want to work on and click on the dropdown menu that should say “main”. It should look like the following image.\n\n\n\nBranch Menu in GitHub\n\n\nOnce you click on this menu, a text box appears on GitHub saying “Find or create a branch…”, you enter a new name for the branch, e.g. ‘newbranch1’. Since this branch doesn’t exist yet, GitHub asks you if you want to create a branch with the name “newbranch1”. Click on “Create branch: newbranch1” and the new branch will be created for you, as shown in the following image.\n\n\n\nCreate a new branch\n\n\n\n\nHow do you make a pull request?\nA pull request allows the owner of the GitHub project to review your changes to make sure they fit into the current repository and don’t cause conflicts in your repository.\nTo make a pull request from your branch, you must first make a change to your branch repository. Once you have made a change to your branch, a yellow bar will appear on your screen asking you if you want to make a pull request. As you can see in the picture below, there is a green button, and as soon as you click on it, you can create a pull request.\n\n\n\nInitialisation of a pull request\n\n\nOnce you click on the button, GitHub will inform you if there are any problems merging the branch with the main project. If there are no problems, GitHub will put a tick and show “Able to merge”. You can then add a title and comment to your pull request to let the repository owner know what you’ve done. Once you have entered a comment and a title, you can click on “Create a pull request”. Once you have done this, a notification will be sent to the repository owner that your changes are ready for review.\nAfter you submit your request, the GitHub project owner can go to the project’s page and click on the “Pull Requests” tab. This page will display a list of pull requests from which the owner can select your request. Once on the Pull Request page, the owner will see a button that says “Merge pull request” (similar to the image below).\n\n\n\nEdit a pull request\n\n\nOnce the owner clicks on the green button, he will be asked again if he wants to make the change. When he clicks the button again, the change is merged with the main branch and he sees something like the following picture….\n\n\n\nMerge a verified pull request\n\n\n\n\n\nUpdating a repository in a branch (or fork)\nWhen someone in your group makes a change to the master repo, there is a way to update your branch so you can see the changes. When a change is made, the branched repo web page will show that your repo is “1 commit behind the master”. This means that there is 1 change between your fork and the main repository.\nIf you want to update your fork, click on the “Changes” button. You will then be taken to a page that says “main is up to date with all commits from branch. Try changing the base”. Click on “Change base”. It will then show if the branch can be merged. If so, click on `Create pull request’ (title and comment for your request) and create a pull request.\nNow click on ‘Merge pull request’, then on ‘Confirm merge’ and your branch will be updated!\n\n\nGood to know\n\n\nLearn how to create branches using the terminal: Working with Branches\nLearn how to use pull requests and issues: Issues and Pull Requests\nLearn how to fork a GitHub repository: forking a repository\n\n\n\n\nSelf-check"
  },
  {
    "objectID": "modules/en-git-module.html#dealing-with-conflicts",
    "href": "modules/en-git-module.html#dealing-with-conflicts",
    "title": "Git, GitHub & Rstudio [EN]",
    "section": "Dealing with conflicts",
    "text": "Dealing with conflicts\n\nLearning objectives\nIn this lesson you will learn\n\nHow to deal with conflicts that arise when working with GitHub.\nHow to deal with merge conflicts in GitHub.\n\n\n\nPrerequisites\n\nFamiliarity with GitHub.\nHave Git installed.\nHave a GitHub account.\n\n\n\nVersion conflict - what is it?\nVersion conflicts usually occur when different versions of the same file are pushed to the main repository at the same time and the prioritisation of the files is not clear, ie:\n\nwhen updating one’s personal GitHub repository (no pull before push).\nwhen several people are working on the same file at the same time\n\n\n\nPush & Pull conflicts\nA typical scenario is that you edit something online on GitHub and don’t sync that change to Rstudio at the same time or later. The conflict could be, for example you fix a typo in the README and forget to update the current version in the Rstudio project.\nA more complicated case is when a change has been made in the master repository and someone else in their branch/fork repository has also made a change to the same file/content. the same content. When a pull request is made, GitHub will notice the difference. Again, it may be something as simple as two people updating the README in different ways, causing GitHub to report a problem.\nIn this case, you have to manually decide which variant takes precedence.\nIf you make a change to your GitHub repository and there is a conflict, R will show you that your version is ahead of the master repository when you commit your change. If you see this, it means there is a difference between the files. If you try to commit and there is a problem, GitHub will tell you something like\n\nUpdates were rejected because the remote repository contains work that you don’t have locally. This is usually caused by another repository pushing to the same reference.\n\nWhen this message appears, GitHub recommends that you do a pull from your master repository to find the error. Often you will get the error message\n\nCONFLICT (content): Conflict merging into [file]. Automatic merge failed; resolve conflicts and then commit the result.\n\nThe file with the problem is then opened in your RStudio and shows the error found. It shows what changes have been made and what differences there are to the main branch (the changes are shown under ‘&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD’, the contents of the main branch are shown underneath). You need to fix the bug between the two versions, either by keeping what GitHub already has, or by tweaking your change to match what you wanted to do. When you are happy with your change, open the terminal (located in R, a tab above the console). In the terminal, type git add [filename], press Enter and go back to the Git tab at the top right of the RStudio window. Select the file where the error occurred and overwrite it to fix the error.\n\n\nMerge conflicts\nIf multiple people are working on the same GitHub repository or you are only using one branch, there is a chance that a merge conflict will occur. Merge conflicts occur when changes are made to the main repository and to a branch that do not match. Once a pull request is made, the repository owner must manually review the changes, they cannot then be merged automatically.\nConsequently, GitHub will tell you that it cannot automatically merge the versions, but it will still allow you to make the pull request. If you decide to send the pull request, the repo owner will not be able to click the green merge button, but will see a message saying:\n:: warning This branch has conflicts that need to be resolved. :::\nTo the right of this message is the Resolve Conflicts button.\nWhen you click on the ‘Resolve conflicts’ button, you will be taken to a page that looks similar to push or pull errors. You will see the suggested changes from the branch and main repository. At this point, changes can then be made and finally successfully deployed for a merge with Mark as Resolved and then Confirm Merge. Finally, the owner must click Merge Pull Request and then Commit Merge to make the change in the master repository.\n\n\nGood to know\n\n\nAlways pull before push, otherwise GitHub will have two different changes stored and won’t know which one to use.\nFor more information about handling conflicts in GitHub, see the GitHub Docs.\n\n\n\n\nSelf-check"
  },
  {
    "objectID": "modules/en-git-module.html#rstudio---all-inclusive",
    "href": "modules/en-git-module.html#rstudio---all-inclusive",
    "title": "Git, GitHub & Rstudio [EN]",
    "section": "RStudio - All Inclusive",
    "text": "RStudio - All Inclusive\n\nLearning objectives\n\nUsing GitHub directly from RStudio\n\n\n\nPrerequisites\n\nPractice in working with GitHub and git\n\n\n\nIntegrating an existing GitHub repo into R\nBefore working with a GitHub repository in RStudio, make sure you have a GitHub repository to work with.\nAfter you have created the repository, you can click the green button to get a link to clone the repository. To open it in R, open R and click on the cube with the plus sign to create a new project, click on version control and then on Git. Now paste the URL you copied earlier and create the project. Now you have a project in R that is connected to GitHub. Now you can create new files and upload them to GitHub for others to see.\n\n\nExplanation of the buttons/commands\nOn the top right (depending on the configuration of RStudio) you will find the tabs Environment, History... Select the tab Git to see the Git commands. In this section you can decide which files to upload/delete, which changes to apply, which files to pull from the master repository, which files to push to the master repository. The changes made are checked here and branches can be created or changed. Let’s now look at what the individual commands/buttons do.\n\nDiff` If you click on Diff, a new window opens in R. This window shows all the files that have changed (compared to the main repository) and also the changes you have made. You can also use this window to commit the changes and move them out of the main repository.\nCommit` Using Commit in the smaller window is similar to using it in the Diff window, you just need to select the files you want to commit to the repository and then commit the changes.\nPull Pull is pretty self-explanatory, it pulls files from the GitHub repository. It is important to pull files before pushing to avoid possible conflicts with overlapping files.\nPush pushes the files into the GitHub repository. This feature is used when you have finished making changes to your files and are ready to upload them so others can view the new files. The order for uploading these files would be: commit changes, pull from the repository and then push to the repository.\nHistory The next icon is a small clock that represents the history of your work. It shows the previous commits and what was changed in each commit.\nRevert, Ignore and Shell’ These commands can be found in a dropdown menu after clicking on the gear next to the clock. With Revert you can undo all changes, with Ignore you can set up a gitignore (useful to block files you don’t want to upload) and with Shell you can open your terminal and execute git commands there.\nBranches’ The next icon stands for branches. When you click on this icon, you will be asked if you want to create a new branch. As you learned in the Branches module of the Toolkit, branches are useful for testing changes without affecting the main branch in case an error occurs. You can use the drop-down menu to the right of the branch icon to switch between branches.\nTerminal (optional) You can run these GitHub commands with the RStudio commands, but you can also use the terminal in R to do the same. All GitHub commands are in the form “git _____” and you can find them by typing “git” into your terminal. This does the same as the R panel, but if you are more familiar with writing git commands in a terminal, it may work better for you.\n\n\nTurning an R project into a GitHub repository\nSometimes you are working on a project in R and you forgot to create a GitHub repository for it. In this case, the package usethis can help you create a repo from within RStudio. With the function usethis::use_git the current project can be converted into a GitHub repo so that the files can be uploaded. - If you run this function for the first time, you will probably get an error, as you need a token from GitHub to do this. After calling usethis::browse_github_token a new window will open asking you to log in to your GitHub account. After logging in, permissions can be set and copied with the token. Once you have copied the token, call usethis::edit_r_environment() and save your token as “GITHUB_PAT=token”.\nOnce your token is set and your R is reset, you can use use_git and it will ask you if it is OK to commit your files to GitHub. If you answer yes to this question, you will be asked to restart your RStudio window to open the Git window and upload your files. After restarting RStudio, upload the changed files (if any) using the diff button. Now use usethis::use_github to send your files to a GitHub repository. - use_github will ask you if you have an ssh key, which you probably don’t, so choose https. Then you will be asked if the title and description are acceptable. If so, you can answer yes and upload the file to GitHub!\n\n\n\nGood to know\n\nFor more information on using GitHub in RStudio, see the following link:\n\nThe blog entry GitHub & Rstudio shows how to use Git in RStudio and goes into particular detail about the terminal commands.\n\n\n\n\n\n\nSelf-check"
  },
  {
    "objectID": "modules/en-git-module.html#acknowledgements",
    "href": "modules/en-git-module.html#acknowledgements",
    "title": "Git, GitHub & Rstudio [EN]",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThe tutorial is based on the DoSStoolkit. especially using the module Git outta here by Mariam Walaa & Matthew Wankiewicz. The translations and modifications as well as some of the graphics are by the author of this page.\nThe original module can be called with the following R command.\n\nlearnr::run_tutorial(\"git_outta_here\", package = \"DoSStoolkit\")"
  },
  {
    "objectID": "modules/slidelist.html",
    "href": "modules/slidelist.html",
    "title": "Self-study modules",
    "section": "",
    "text": "Git, GitHub & Rstudio [DE]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGit, GitHub & Rstudio [EN]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "assessment/slidelist.html",
    "href": "assessment/slidelist.html",
    "title": "Assessments",
    "section": "",
    "text": "Basic Exercise\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "slides/slide1.html#header-12",
    "href": "slides/slide1.html#header-12",
    "title": "Slides and extensions",
    "section": "Header (1|2)",
    "text": "Header (1|2)\nThe support of header and footer logic is provided by the plugin reveal-header. it is activated by:\nfilters:\n  - reveal-header"
  },
  {
    "objectID": "slides/slide1.html#header-22",
    "href": "slides/slide1.html#header-22",
    "title": "Slides and extensions",
    "section": "Header (2|2)",
    "text": "Header (2|2)\nIn this example you will find a basic header and footer text, pagination and a logo in the upper left corner .\n---\ntitle: \"Slides and extensions\"\nsubtitle: \"basically shows the 3 extensions samples\"\ntitle-slide-attributes:\n  data-background-image: slide1/mof.png\n  data-background-size: contain\n  data-background-opacity: \"0.5\"\nformat: \n  revealjs:\n    slide-number: true\n    footer: &lt;gisma 2023&gt;\n    header: This is the header extension\n    header-logo: slide1/logooil.jpg\n[...]\n---"
  },
  {
    "objectID": "slides/slide1.html#spotlight-12",
    "href": "slides/slide1.html#spotlight-12",
    "title": "Slides and extensions",
    "section": "Spotlight (1|2)",
    "text": "Spotlight (1|2)\nThe support of a pointer or similar pointing features is provided by the plugin spotlight. it is activated by:\nrevealjs-plugins:\n  - spotlight"
  },
  {
    "objectID": "slides/slide1.html#spotlight-22",
    "href": "slides/slide1.html#spotlight-22",
    "title": "Slides and extensions",
    "section": "Spotlight (2|2)",
    "text": "Spotlight (2|2)\nCurrently the spotlight is set to a red dot pointer. Just press the left mouse button and use it. It is defined in the header:\n---\n[...]\nformat: \n  revealjs:\n    slide-number: true\n    footer: &lt;gisma 2023&gt;\n    header: This is the header extension\n    header-logo: slide1/logooil.jpg\n    spotlight:\n      useAsPointer: true\n      size: 5\n\nfilters:\n  - roughnotation\n  - reveal-header\nrevealjs-plugins:\n  - spotlight\n---"
  },
  {
    "objectID": "slides/slide1.html#highlighting-concept",
    "href": "slides/slide1.html#highlighting-concept",
    "title": "Slides and extensions",
    "section": "Highlighting concept",
    "text": "Highlighting concept\nThe support of complex highlighting etc. is provided by the plugin roughnotation. it is activated by:\nfilters:\n  - roughnotation\nTo activate the highlighting interactively press the r key. It will start any notation animations:\nI will be highlighted, and so will these words right here"
  },
  {
    "objectID": "slides/slide1.html#options",
    "href": "slides/slide1.html#options",
    "title": "Slides and extensions",
    "section": "Options",
    "text": "Options\nThere are many types of options we can use (Press r to show)\n\ntype\nanimate\nanimationDuration\ncolor\nstrokeWidth\nmultiline multiline multiline multiline multiline multiline multiline multiline multiline multiline\niterations\nrtl"
  },
  {
    "objectID": "slides/slide1.html#options-1",
    "href": "slides/slide1.html#options-1",
    "title": "Slides and extensions",
    "section": "Options",
    "text": "Options\n(Press r to show)\nThe options are applied by adding arguments like so {.rn rn-color=orange rn-type=circle}\nSo to add a orange circle or turn off animations by adding rn-animate=false\nNote that the arguments are all prefixed with rn-, are not comma-separated, logical values are written as true or false and that strings do not have to be in quotes"
  },
  {
    "objectID": "slides/slide1.html#options---types",
    "href": "slides/slide1.html#options---types",
    "title": "Slides and extensions",
    "section": "Options - types",
    "text": "Options - types\n(Press r to show)\n\n\nUnderline\nBox\nCircle\nHighlight\nStrike-Through\nCrossed-off\n\nMany types to choose from!\nHyphenated options can be used like so rn-type=strike-through"
  },
  {
    "objectID": "slides/slide1.html#options---multiline",
    "href": "slides/slide1.html#options---multiline",
    "title": "Slides and extensions",
    "section": "Options - Multiline",
    "text": "Options - Multiline\n(Press r to show)\nThe options rn-multiline=true can be added to make a highligher work across multiple lines.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed accumsan nisi hendrerit augue molestie tempus. Phasellus purus quam, aliquet nec commodo quis, pharetra ut orci. Donec laoreet ligula nisl, placerat molestie mauris luctus id. Fusce dapibus non libero nec lobortis."
  },
  {
    "objectID": "slides/slide1.html#all-about-time",
    "href": "slides/slide1.html#all-about-time",
    "title": "Slides and extensions",
    "section": "All about Time",
    "text": "All about Time\n(Press r to show)\nUnless otherwise specified, all annotations will occur at the same time. Set the rn-index to specify order\nNo rn-index\nrn-index set to 1\nrn-index set to 2\nrn-index set to 3\nrn-index set to 4"
  },
  {
    "objectID": "slides/slide1.html#fenced-divs",
    "href": "slides/slide1.html#fenced-divs",
    "title": "Slides and extensions",
    "section": "Fenced divs",
    "text": "Fenced divs\nYou can also use fenced divs if you want to apply the changes to larger sections of of the slide\n::: {.rn rn-type=box rn-color=red}\nHere is some text\n\nAnd there is more here\n:::\n\nHere is some text\nAnd there is more here"
  },
  {
    "objectID": "slides/slide1.html#known-issues",
    "href": "slides/slide1.html#known-issues",
    "title": "Slides and extensions",
    "section": "Known issues",
    "text": "Known issues\ndoesn’t show correctly in RStudio IDE\nDepending on Browser and setting use the CTRL +/- zoom to place the highlights at the correct places"
  },
  {
    "objectID": "slides/slide1.html#basic-reference",
    "href": "slides/slide1.html#basic-reference",
    "title": "Slides and extensions",
    "section": "Basic Reference",
    "text": "Basic Reference\nFind more informations at Quarto RevealJS Documentation\n\n\n&lt;gisma 2023&gt;\n\n\n\n\n\n\n \n\n\nThis is the header extension"
  },
  {
    "objectID": "slides/slidelist.html",
    "href": "slides/slidelist.html",
    "title": "Presentations",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nSlides and extensions\n\n\ngisma team\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "base/impressum.html#content-responsibility",
    "href": "base/impressum.html#content-responsibility",
    "title": "Impressum",
    "section": "Content Responsibility",
    "text": "Content Responsibility\nThe responsibility for the content rests with the instructors. Statements, opinions and/or conclusions are the ones from the instructors and do not necessarily reflect the opinion of the representatives of Marburg University."
  },
  {
    "objectID": "base/impressum.html#content-license",
    "href": "base/impressum.html#content-license",
    "title": "Impressum",
    "section": "Content License",
    "text": "Content License\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n\nPrivacy Policy\n\n\nAs of 21. October 2021\n\n\nIntroduction\n\n\nWith the following data protection declaration, we would like to inform you about the types of your personal data (hereinafter also referred to as “data” for short) that we process, for what purposes and to what extent. The privacy policy applies to all processing of personal data carried out by us, both in the context of the provision of our services and in particular on our websites, in mobile applications and within external online presences, such as our social media profiles (hereinafter collectively referred to as “Online Offerings”).\n\n\nThe terms used are not gender-specific.\n\n\nResponsible\n\n\nDr Christoph ReudenbachDeutschhaustr 1035037 Marburg\n\n\nEmail address: reudenbach@uni-marburg.de.\n\n\nImprint: https://www.uni-marburg.de/de/impressum.\n\n\nOverview of Processing\n\n\nThe following overview summarizes the types of data processed and the purposes of their processing, and refers to the data subjects.\n\n\nTypes of Data Processed\n\n\n\nContent data (e.g. input in online forms).\n\n\nContact data (e.g. email, phone numbers).\n\n\nMeta/communication data (e.g. device information, IP addresses).\n\n\nUse data (e.g. websites visited, interest in content, access times).\n\n\n\nCategories of data subjects\n\n\n\nCommunication partners.\n\n\nUsers (e.g.. Website visitors, users of online services).\n\n\n\nPurposes of processing\n\n\n\nDirect marketing (e.g., by email or postal mail).\n\n\nContact requests and communications.\n\n\n\nRelevant legal basis\n\n\nThe following is an overview of the legal basis of the GDPR on the basis of which we process personal data. Please note that in addition to the provisions of the GDPR, national data protection regulations may apply in your or our country of residence or domicile. Furthermore, should more specific legal bases be decisive in individual cases, we will inform you of these in the data protection declaration.\n\n \n\n\nConsent (Art. 6 para. 1 p. 1 lit. a. DSGVO) - The data subject has given his or her consent to the processing of personal data concerning him or her for a specific purpose or purposes.\n\n\nRegistered interests (Art. 6 para. 1 p. 1 lit. f. DSGVO) - Processing is necessary to protect the legitimate interests of the controller or a third party, unless such interests are overridden by the interests or fundamental rights and freedoms of the data subject which require the protection of personal data.\n\n\n\nNational data protection regulations in Germany: In addition to the data protection regulations of the General Data Protection Regulation, national regulations on data protection apply in Germany. These include, in particular, the Act on Protection against Misuse of Personal Data in Data Processing (Federal Data Protection Act - BDSG). In particular, the BDSG contains special regulations on the right to information, the right to erasure, the right to object, the processing of special categories of personal data, processing for other purposes and transmission, as well as automated decision-making in individual cases, including profiling. Furthermore, it regulates data processing for employment purposes (Section 26 BDSG), in particular with regard to the establishment, implementation or termination of employment relationships as well as the consent of employees. Furthermore, state data protection laws of the individual federal states may apply.\n\n \n\nSecurity measures\n\n\nWe take appropriate technical and organizational measures in accordance with the legal requirements, taking into account the state of the art, the implementation costs and the nature, scope, circumstances and purposes of the processing, as well as the different probabilities of occurrence and the extent of the threat to the rights and freedoms of natural persons, in order to ensure a level of protection appropriate to the risk.\n\n.\n\nMeasures include, in particular, ensuring the confidentiality, integrity, and availability of data by controlling physical and electronic access to data as well as access to, entry into, disclosure of, assurance of availability of, and segregation of data concerning them. Furthermore, we have established procedures to ensure the exercise of data subjects’ rights, the deletion of data, and responses to data compromise. Furthermore, we take the protection of personal data into account as early as the development or selection of hardware, software as well as procedures in accordance with the principle of data protection, through technology design and through data protection-friendly default settings.\n\n \n\nDeletion of data\n\n\nThe data processed by us will be deleted in accordance with legal requirements as soon as their consents permitted for processing are revoked or other permissions cease to apply (e.g. if the purpose of processing this data has ceased to apply or it is not necessary for the purpose).\n\n \n\nIf the data are not deleted because they are required for other and legally permissible purposes, their processing will be limited to these purposes. That is, the data will be blocked and not processed for other purposes. This applies, for example, to data that must be retained for reasons of commercial or tax law or whose storage is necessary for the assertion, exercise or defense of legal claims or for the protection of the rights of another natural person or legal entity.\n\n \n\nOur privacy notices may also include further information on the retention and deletion of data that takes precedence for the processing operations in question.\n\n \n\nUse of cookies\n\n\nCookies are text files that contain data from websites or domains visited and are stored by a browser on the user’s computer. The primary purpose of a cookie is to store information about a user during or after their visit within an online site. Stored information may include, for example, language settings on a website, login status, a shopping cart, or where a video was watched. We further include in the term cookies other technologies that perform the same functions as cookies (e.g., when user details are stored using pseudonymous online identifiers, also referred to as “user IDs”)\n\n.\n\nThe following cookie types and functions are distinguished:\n\n\n\nTemporary cookies (also: session or session cookies): Temporary cookies are deleted at the latest after a user has left an online offer and closed his browser.\n\n\nPermanent cookies: Permanent cookies remain stored even after closing the browser. For example, the login status can be saved or preferred content can be displayed directly when the user revisits a website. Likewise, the interests of users used for range measurement or marketing purposes can be stored in such a cookie.\n\n\nFirst-party cookies: First-party cookies are set by ourselves.\n\n\nThird-party cookies (also: third-party cookies): Third-party cookies are mainly used by advertisers (so-called third parties) to process user information.\n\n\nNecessary (also: essential or absolutely necessary) cookies: Cookies may be absolutely necessary for the operation of a website (e.g. to store logins or other user input or for security reasons).\n\n\nStatistics, marketing and personalization cookies: Furthermore, cookies are usually also used in the context of range measurement and when the interests of a user or his behavior (e.g. viewing certain content, use of functions, etc.) on individual web pages are stored in a user profile. Such profiles are used, for example, to show users content that matches their potential interests. This process is also referred to as “tracking”, i.e., tracking the potential interests of users. Insofar as we use cookies or “tracking” technologies, we will inform you separately in our privacy policy or in the context of obtaining consent.\n\n\n\nNotes on legal bases: On which legal basis we process your personal data using cookies depends on whether we ask you for consent. If this is the case and you consent to the use of cookies, the legal basis for the processing of your data is the declared consent. Otherwise, the data processed with the help of cookies is processed on the basis of our legitimate interests (e.g. in a business operation of our online offer and its improvement) or, if the use of cookies is necessary to fulfill our contractual obligations.\n\n.\n\nDuration of storage: If we do not provide you with explicit information about the storage period of permanent cookies (e.g. in the context of a so-called cookie opt-in), please assume that the storage period can be up to two years.\n\n.\n\nGeneral information on revocation and objection (opt-out):  Depending on whether the processing is based on consent or legal permission, you have the option at any time to revoke any consent given or to object to the processing of your data by cookie technologies (collectively referred to as “opt-out”). You can initially declare your objection by means of your browser settings, e.g. by deactivating the use of cookies (whereby this may also restrict the functionality of our online offer). An objection to the use of cookies for online marketing purposes can also be declared by means of a variety of services, especially in the case of tracking, via the websites https://optout.aboutads.info and https://www.youronlinechoices.com/. In addition, you can receive further objection notices in the context of the information on the service providers and cookies used.\n\n.\n\nProcessing of cookie data on the basis of consent: We use a cookie consent management procedure, in the context of which the consent of users to the use of cookies, or the processing and providers mentioned in the cookie consent management procedure can be obtained and managed and revoked by users. Here, the declaration of consent is stored in order not to have to repeat its query and to be able to prove the consent in accordance with the legal obligation. The storage can take place on the server side and/or in a cookie (so-called opt-in cookie, or with the help of comparable technologies), in order to be able to assign the consent to a user or their device. Subject to individual information on the providers of cookie management services, the following information applies: The duration of the storage of consent can be up to two years. Here, a pseudonymous user identifier is formed and stored with the time of consent, information on the scope of consent (e.g., which categories of cookies and/or service providers) as well as the browser, system and end device used.\n\n.\n\n\nTypes of data processed: Usage data (e.g. websites visited, interest in content, access times), meta/communication data (e.g. device information, IP addresses).\n\n\nPersons concerned: Users (e.g. website visitors, users of online services).\n\n\nLegal basis: Consent (Art. 6 para. 1 p. 1 lit. a. DSGVO), Legitimate Interests (Art. 6 para. 1 p. 1 lit. f. DSGVO).\n\n\n\nSurveys and polls\n\n\nThe surveys and polls (hereinafter “surveys”) conducted by us are evaluated anonymously. Personal data is only processed insofar as this is necessary for the provision and technical implementation of the surveys (e.g. processing of the IP address to display the survey in the user’s browser or to enable a resumption of the survey with the help of a temporary cookie (session cookie)) or users have consented.\n\n.\n\nNotes on legal basis: If we ask participants for consent to process their data, this is the legal basis of the processing, otherwise the processing of participants’ data is based on our legitimate interests in conducting an objective survey.\n\n \n\n\nTypes of data processed: Contact data (e.g. email, phone numbers), content data (e.g. input in online forms), usage data (e.g. web pages visited, interest in content, access times), meta/communication data (e.g. device information, IP addresses).\n\n\nParticipants concerned: Communication partners.\n\n\nPurposes of processing: Contact requests and communication, direct marketing (e.g. by e-mail or postal mail).\n\n\nLegal basis: Consent (Art. 6 para. 1 p. 1 lit. a. DSGVO), Legitimate Interests (Art. 6 para. 1 p. 1 lit. f. DSGVO).\n\n\n\nChange and Update Privacy Policy\n\n\nWe encourage you to periodically review the contents of our Privacy Policy. We adapt the Privacy Policy as soon as the changes in the data processing activities we carry out make it necessary. We will inform you as soon as the changes require an act of cooperation on your part (e.g. consent) or other individual notification.\n\n.\n\nWhere we provide addresses and contact information for companies and organizations in this Privacy Policy, please note that addresses may change over time and please check the information before contacting us.\n\n.\n\nRights of data subjects\n\n\nAs a data subject, you are entitled to various rights under the GDPR, which arise in particular from Art. 15 to 21 DSGVO:\n\n\n\nRight to object: You have the right to object at any time, on grounds relating to your particular situation, to the processing of personal data relating to you which is carried out on the basis of Art. 6(1)(e) or (f) DSGVO; this also applies to profiling based on these provisions. If the personal data concerning you is processed for the purpose of direct marketing, you have the right to object at any time to the processing of personal data concerning you for the purpose of such marketing; this also applies to profiling, insofar as it is associated with such direct marketing.\n\n\nRight of withdrawal in the case of consent: You have the right to withdraw any consent you have given at any time.\n\n\nRight of access: You have the right to request confirmation as to whether data in question is being processed and to information about this data, as well as further information and copy of the data in accordance with the legal requirements.\n\n\nRight of rectification: You have the right, in accordance with the legal requirements, to request the completion of the data concerning you or the correction of incorrect data concerning you.\n\n\nRight to erasure and restriction of processing: You have, in accordance with the law, the right to request that data concerning you be erased without undue delay, or alternatively, in accordance with the law, to request restriction of the processing of the data.\n\n\nRight to data portability: You have the right to receive data concerning you, which you have provided to us, in a structured, common and machine-readable format in accordance with the legal requirements, or to demand its transfer to another responsible party.\n\n\nComplaint to supervisory authority: Without prejudice to any other administrative or judicial remedy, you have the right to lodge a complaint with a supervisory authority, in particular in the Member State of your habitual residence, place of work or the place of the alleged infringement, if you consider that the processing of personal data concerning you infringes the requirements of the GDPR.\n\n\n.\n\nDefinitions of Terms\n\n\nThis section provides you with an overview of the terms used in this Privacy Policy. Many of the terms are taken from the law and defined primarily in Article 4 of the GDPR. The legal definitions are binding. The following explanations, on the other hand, are primarily intended to aid understanding. The terms are sorted alphabetically.\n\n \n\n\nPersonal data: “Personal data” means any information relating to an identified or identifiable natural person (hereinafter “data subject”); an identifiable natural person is one who can be identified, directly or indirectly, in particular by reference to an identifier such as a name, an identification number, location data, an online identifier (eg. e.g. cookie) or to one or more special characteristics that are an expression of the physical, physiological, genetic, mental, economic, cultural or social identity of that natural person.\n\n\nController: The “controller” is the natural or legal person, public authority, agency or other body which alone or jointly with others determines the purposes and means of the processing of personal data.\n\n\nProcessing: “Processing” means any operation or set of operations which is performed upon personal data, whether or not by automatic means. The term is broad and includes virtually any handling of data, whether collecting, evaluating, storing, transmitting or deleting.\n\n\n\nCreated with free Datenschutz-Generator.de by Dr. Thomas Schwenke"
  },
  {
    "objectID": "base/impressum.html#comments-suggestions",
    "href": "base/impressum.html#comments-suggestions",
    "title": "Impressum",
    "section": "Comments & Suggestions",
    "text": "Comments & Suggestions"
  },
  {
    "objectID": "base/about.html",
    "href": "base/about.html",
    "title": "About this site",
    "section": "",
    "text": "About this site\nThis page summarizes the essential workflows , basic literature and web resources from the distributed course systems , documents and field protocols into a knowledge base.\nAlthough the web space is topic-centered any keyword can be searched using the full text search.\nThe creation of new pages, the editing of existing pages can be triggered directly via the right column online.\nOffline there are several visual editors and full integration with Rstudio etc."
  },
  {
    "objectID": "base/faq.html",
    "href": "base/faq.html",
    "title": "Frequently asked Questions",
    "section": "",
    "text": "This is a senseless question to meet a meaningfull answer\n\n\n\n\n\n\n\n\n\nThis is a meaningful answer to a senseless question\n\n\n\n\n\n\n\n\n\nLearn More…\n\n\n\n\n\nThis is a even more meaningful answer to a senseless question"
  },
  {
    "objectID": "base/faq.html#make-sense-topic",
    "href": "base/faq.html#make-sense-topic",
    "title": "Frequently asked Questions",
    "section": "",
    "text": "This is a senseless question to meet a meaningfull answer\n\n\n\n\n\n\n\n\n\nThis is a meaningful answer to a senseless question\n\n\n\n\n\n\n\n\n\nLearn More…\n\n\n\n\n\nThis is a even more meaningful answer to a senseless question"
  },
  {
    "objectID": "uav/listing1.html",
    "href": "uav/listing1.html",
    "title": "Software & Materials",
    "section": "",
    "text": "Micro-Remote-Sensing course materials\nBasic Flight Planning¶ with uavRmp. Tutorials how to plan survey flights with the uavRmp package.\nUsing QgroundControl¶ with uavRmp. Tutorials how to plan survey flights with the uavRmp package.\nGetting Started Youtube guide for using QGroundControl"
  },
  {
    "objectID": "uav/listing1.html#things-you-need",
    "href": "uav/listing1.html#things-you-need",
    "title": "Software & Materials",
    "section": "",
    "text": "Micro-Remote-Sensing course materials\nBasic Flight Planning¶ with uavRmp. Tutorials how to plan survey flights with the uavRmp package.\nUsing QgroundControl¶ with uavRmp. Tutorials how to plan survey flights with the uavRmp package.\nGetting Started Youtube guide for using QGroundControl"
  },
  {
    "objectID": "uav/listing1.html#software",
    "href": "uav/listing1.html#software",
    "title": "Software & Materials",
    "section": "Software",
    "text": "Software"
  },
  {
    "objectID": "uav/listing1.html#hardware",
    "href": "uav/listing1.html#hardware",
    "title": "Software & Materials",
    "section": "Hardware",
    "text": "Hardware"
  },
  {
    "objectID": "uav/planning.html#software",
    "href": "uav/planning.html#software",
    "title": "Planning UAV survey flights",
    "section": "Software",
    "text": "Software"
  },
  {
    "objectID": "uav/planning.html#hardware",
    "href": "uav/planning.html#hardware",
    "title": "Planning UAV survey flights",
    "section": "Hardware",
    "text": "Hardware"
  },
  {
    "objectID": "uav/uav-index.html#software",
    "href": "uav/uav-index.html#software",
    "title": "Budget UAVs",
    "section": "Software",
    "text": "Software"
  },
  {
    "objectID": "uav/uav-index.html#hardware",
    "href": "uav/uav-index.html#hardware",
    "title": "Budget UAVs",
    "section": "Hardware",
    "text": "Hardware"
  },
  {
    "objectID": "uav/products.html#software",
    "href": "uav/products.html#software",
    "title": "Orthomimages and Point Clouds from UAV",
    "section": "Software",
    "text": "Software"
  },
  {
    "objectID": "uav/products.html#hardware",
    "href": "uav/products.html#hardware",
    "title": "Orthomimages and Point Clouds from UAV",
    "section": "Hardware",
    "text": "Hardware"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to the gisma knowledgebase web space",
    "section": "",
    "text": "Welcome to the gisma knowledgebase web space\nThis site concisely summarizes workflow knowledge and resources on a wide variety of GI, sensor-based data collection and modeling topics. It is explicitly designed as a practice-focused knowledge workshop"
  },
  {
    "objectID": "mclim/mc-index.html",
    "href": "mclim/mc-index.html",
    "title": "Fine Offset: Weather and environmental sensors",
    "section": "",
    "text": "froggit shop [DE]\n  \n  \n    \n     ecowitt shop [US]\n  \n  \n    \n     Fine Offset\n  \n\n      \nThe sensors from Fine Offset are re-branded and partly modified by the resellers. This article deals with sensors from the german re-seller froggit and the US re-seller ecowitt. More precise the DP-/GW SmartHubs WiFi Gateway with temperature, humidity & Pressure which is developed by fine offset. The unique selling point of the LoRa-Wifi gateway is the extraordinarily extensive possibility of connecting radio-bound sensors."
  },
  {
    "objectID": "mclim/mc-index.html#calibration-concept",
    "href": "mclim/mc-index.html#calibration-concept",
    "title": "Fine Offset: Weather and environmental sensors",
    "section": "Calibration Concept",
    "text": "Calibration Concept\nThe low budget sensors are usually lacking of a stable measurement quality. To obtain reliable micro climate data a two step calibration process is suggested.\n\nThe measurements of all sensors (preferably in a climate chamber) will be statistically analysed to identify sensor which produce systematic and significant outliers.\nThe sensors are calibrated against an operational running high price reference station in the field.\n\n\n\n\n\n\n\nFuture Calibration Plans\n\n\n\n\n\nFor the future a machine learning approach including the radiation, azimuth, temperature and humidity as predictors for the calibrated temperature as the response variable will be used as an rolling calibration tool."
  },
  {
    "objectID": "mclim/sensors.html",
    "href": "mclim/sensors.html",
    "title": "Microclimate stations",
    "section": "",
    "text": "Currently several WiFi Hubs with varying sensors and one base station each are connected via LoRa radio. The base station is equipped with wind vector, precipitation irradiance and temperature/humidity sensors. The WiFi Hub in turn uses any accessible WLAN to pass on the data via mobile network to a data server."
  },
  {
    "objectID": "mclim/sensors.html#hardware",
    "href": "mclim/sensors.html#hardware",
    "title": "Microclimate stations",
    "section": "Hardware",
    "text": "Hardware"
  },
  {
    "objectID": "mclim/sensors.html#setup",
    "href": "mclim/sensors.html#setup",
    "title": "Microclimate stations",
    "section": "Setup",
    "text": "Setup"
  },
  {
    "objectID": "mclim/sensors.html#faq",
    "href": "mclim/sensors.html#faq",
    "title": "Microclimate stations",
    "section": "FAQ",
    "text": "FAQ"
  }
]